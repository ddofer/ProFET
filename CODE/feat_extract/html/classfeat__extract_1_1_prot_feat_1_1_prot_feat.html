<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: feat_extract.ProtFeat.ProtFeat Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>feat_extract</b></li><li class="navelem"><b>ProtFeat</b></li><li class="navelem"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html">ProtFeat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classfeat__extract_1_1_prot_feat_1_1_prot_feat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">feat_extract.ProtFeat.ProtFeat Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3735b241e73d91edf45a4f1edd722ea7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a3735b241e73d91edf45a4f1edd722ea7">__init__</a></td></tr>
<tr class="separator:a3735b241e73d91edf45a4f1edd722ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccaa9437f70532d45069e4eb94c3c21"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a2ccaa9437f70532d45069e4eb94c3c21">GetAA_Freq</a> (self)</td></tr>
<tr class="separator:a2ccaa9437f70532d45069e4eb94c3c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603ae748d2527d00821a9a1f63f007d9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a603ae748d2527d00821a9a1f63f007d9">countToFreq</a> (self, dict_counts)</td></tr>
<tr class="separator:a603ae748d2527d00821a9a1f63f007d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9fe63c2f412f7644cc0a814cc5be37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a7a9fe63c2f412f7644cc0a814cc5be37">ordered_seq_pairs</a></td></tr>
<tr class="separator:a7a9fe63c2f412f7644cc0a814cc5be37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f8c4ea839093b5e33f4c13e894a09"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a437f8c4ea839093b5e33f4c13e894a09">alphabet_prefix</a> (self, res)</td></tr>
<tr class="separator:a437f8c4ea839093b5e33f4c13e894a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158fb3fdf8ae66e27116ca58e25752bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a158fb3fdf8ae66e27116ca58e25752bf">MerCount</a> (self, kmer_counts, k)</td></tr>
<tr class="separator:a158fb3fdf8ae66e27116ca58e25752bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f80df6810f710824dbaab6e30ae3775"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a0f80df6810f710824dbaab6e30ae3775">GetkgramCounts</a></td></tr>
<tr class="separator:a0f80df6810f710824dbaab6e30ae3775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce3fc3e99eea09835b08d8af39e67c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a8ce3fc3e99eea09835b08d8af39e67c5">GetkgramFreq</a></td></tr>
<tr class="separator:a8ce3fc3e99eea09835b08d8af39e67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b59569502aef30304207fe0303b28c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a8b59569502aef30304207fe0303b28c7">GetKMirrorsFreq</a></td></tr>
<tr class="separator:a8b59569502aef30304207fe0303b28c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc57875b17b82b065e4958eb6ec8ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a76dc57875b17b82b065e4958eb6ec8ed">KMirrors</a> (self, k_dict)</td></tr>
<tr class="separator:a76dc57875b17b82b065e4958eb6ec8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9846e49d823597d17b7ce15d959a09"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a5e9846e49d823597d17b7ce15d959a09">GetCTD</a></td></tr>
<tr class="separator:a5e9846e49d823597d17b7ce15d959a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad804cf2dea87e471c03a409a0391b819"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#ad804cf2dea87e471c03a409a0391b819">Get_SimpleProtParam</a> (self)</td></tr>
<tr class="separator:ad804cf2dea87e471c03a409a0391b819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f46aa7f046055c9ab534234e4ad244e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f46aa7f046055c9ab534234e4ad244e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>GetLength</b> (self)</td></tr>
<tr class="separator:a1f46aa7f046055c9ab534234e4ad244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405aa53e6c8e9b6616739c9e176b8214"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a405aa53e6c8e9b6616739c9e176b8214">GetFlex</a> (self)</td></tr>
<tr class="separator:a405aa53e6c8e9b6616739c9e176b8214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e1171ffa3fa544caf662be9d09b292"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a48e1171ffa3fa544caf662be9d09b292">Get_PI</a> (self)</td></tr>
<tr class="separator:a48e1171ffa3fa544caf662be9d09b292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15ef6f96924ec48e50aca6ea91dcbea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#ae15ef6f96924ec48e50aca6ea91dcbea">calculateProteinCharge</a></td></tr>
<tr class="separator:ae15ef6f96924ec48e50aca6ea91dcbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c66b67d86f78d7fd2e9c3f058d07924"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a9c66b67d86f78d7fd2e9c3f058d07924">get_netCharge</a> (self, PH_ranges=[3.5)</td></tr>
<tr class="separator:a9c66b67d86f78d7fd2e9c3f058d07924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5536d99e2ad4ca79f6fd94fc5a74db5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5536d99e2ad4ca79f6fd94fc5a74db5e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>GetAliphaticness</b> (self)</td></tr>
<tr class="separator:a5536d99e2ad4ca79f6fd94fc5a74db5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bf4d24db5ee443363b023dd9a8f120"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#ac7bf4d24db5ee443363b023dd9a8f120">GetPTMMotifs</a> (self)</td></tr>
<tr class="separator:ac7bf4d24db5ee443363b023dd9a8f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3870adebee4ffffdab545c2f79e09dea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a3870adebee4ffffdab545c2f79e09dea">GetCleavageCounts</a></td></tr>
<tr class="separator:a3870adebee4ffffdab545c2f79e09dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11f6df3b4efbe4e0975089b5a255c7a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#ae11f6df3b4efbe4e0975089b5a255c7a">Dict_Keys_prefix</a> (self, multilevelDict, PrefixStr)</td></tr>
<tr class="separator:ae11f6df3b4efbe4e0975089b5a255c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58835d011020b381bdd83d77220d38e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a58835d011020b381bdd83d77220d38e9">Get_ParamScales_Features</a></td></tr>
<tr class="separator:a58835d011020b381bdd83d77220d38e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c12ab62255724b9aa96a04700655df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a41c12ab62255724b9aa96a04700655df">Get_SubSeqParamScales_Features</a></td></tr>
<tr class="separator:a41c12ab62255724b9aa96a04700655df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aeb76a124e0b2d6437c62525d76917"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#af7aeb76a124e0b2d6437c62525d76917">Get_ParamScales</a></td></tr>
<tr class="separator:af7aeb76a124e0b2d6437c62525d76917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fee91bd4a79b007cbacc83d20b70f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a55fee91bd4a79b007cbacc83d20b70f7">BinaryAutocorrellation</a></td></tr>
<tr class="separator:a55fee91bd4a79b007cbacc83d20b70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e9a7e4395849f24708b5c29cd61eb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a24e9a7e4395849f24708b5c29cd61eb0">GetEntropy</a></td></tr>
<tr class="separator:a24e9a7e4395849f24708b5c29cd61eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac133108c6d07aa0f3037758307df04a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#ac133108c6d07aa0f3037758307df04a2">Entropy_Seq</a> (self)</td></tr>
<tr class="separator:ac133108c6d07aa0f3037758307df04a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c37ba385c6fa7e877e27a986c273ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a06c37ba385c6fa7e877e27a986c273ee">tail_properties</a></td></tr>
<tr class="separator:a06c37ba385c6fa7e877e27a986c273ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffaab7c26455e14f5317d574a428e1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#aaffaab7c26455e14f5317d574a428e1c">GetSimpleFeatures</a></td></tr>
<tr class="separator:aaffaab7c26455e14f5317d574a428e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b15dca5d5f7374c06f6d27fd11699a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a15b15dca5d5f7374c06f6d27fd11699a">cysteineMotif</a></td></tr>
<tr class="separator:a15b15dca5d5f7374c06f6d27fd11699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bea8b23af186ae22772ad19d1155206"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bea8b23af186ae22772ad19d1155206"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>cysteineSpaceMotif</b> (self)</td></tr>
<tr class="separator:a4bea8b23af186ae22772ad19d1155206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63273ac1c666696e0c4a3d5abb4480eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#a63273ac1c666696e0c4a3d5abb4480eb">getCysteineMotifs</a></td></tr>
<tr class="separator:a63273ac1c666696e0c4a3d5abb4480eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3d514c79ce995aac26b9744212a9f5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfeat__extract_1_1_prot_feat_1_1_prot_feat.html#ade3d514c79ce995aac26b9744212a9f5">getFIDisorder</a></td></tr>
<tr class="separator:ade3d514c79ce995aac26b9744212a9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab51cd86b2a143cc282cb98c683c71ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab51cd86b2a143cc282cb98c683c71ce7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>seq</b></td></tr>
<tr class="separator:ab51cd86b2a143cc282cb98c683c71ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27db3d8dd292aa26eb55f956e86e1811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27db3d8dd292aa26eb55f956e86e1811"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>alph_set</b></td></tr>
<tr class="separator:a27db3d8dd292aa26eb55f956e86e1811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df19c0a636162d28b14caa40525c658"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df19c0a636162d28b14caa40525c658"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IsStandardAlph</b></td></tr>
<tr class="separator:a6df19c0a636162d28b14caa40525c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9dc56ea73c50510370d8959c26877e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9dc56ea73c50510370d8959c26877e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>alph</b></td></tr>
<tr class="separator:a8b9dc56ea73c50510370d8959c26877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac264af452c71a9ccc1378ea1d6ebbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac264af452c71a9ccc1378ea1d6ebbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_N</b></td></tr>
<tr class="separator:a0ac264af452c71a9ccc1378ea1d6ebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5442aeaafb0e6f716c8ab50ddfd07e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5442aeaafb0e6f716c8ab50ddfd07e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_C</b></td></tr>
<tr class="separator:afd5442aeaafb0e6f716c8ab50ddfd07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770619a25f9d98d731d9663530d8af4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a770619a25f9d98d731d9663530d8af4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>length</b></td></tr>
<tr class="separator:a770619a25f9d98d731d9663530d8af4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf971f44583e5997197aa8f9fc19616"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cf971f44583e5997197aa8f9fc19616"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AA_Counts</b></td></tr>
<tr class="separator:a6cf971f44583e5997197aa8f9fc19616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5322bfd7836ce8195b6d2c9e73468d05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5322bfd7836ce8195b6d2c9e73468d05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Bio_ProtParam</b></td></tr>
<tr class="separator:a5322bfd7836ce8195b6d2c9e73468d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The GetProDes/ProtFeat class collects most sequence features  calculation modules in a class.
Different features  are returned in dictionary-(like) forms.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3735b241e73d91edf45a4f1edd722ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ProteinSequence</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alph_letters</em> = <code>'AA20'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>HAS_N</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>HAS_C</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Input a protein sequence.

ProteinSequence = string, protein's sequence.
(alph) - alph_letters = string of all the amino acids in the alphabet.
 Default is 20 (normal).Required when getting N-grams/K-mer counts,
 so as to count consistently.

 Feature keys/Values must be consistent in training and test! (Or MADE so post-hoc)

 HAS_N = "Does sequence have N_terminal end" (Or is it a 'subsequence').
 HAS_N = "Does sequence have C_terminal end".

 We may want to have called features update the class instance,
 when the feature is "unchanging" ,i.e  AAC, PI.., in addition to
 returning the feature and its values as a dict.</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a437f8c4ea839093b5e33f4c13e894a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.alphabet_prefix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">if non standard/reduced alphabet is used,
then modify feature names (keys in given dictionary)
 of results to have appropiate prefix.

 res = dict of features. Keys = feature names (strings), values: features val.
</pre> 
</div>
</div>
<a class="anchor" id="a55fee91bd4a79b007cbacc83d20b70f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.BinaryAutocorrellation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signal_letters</em> = <code>['K'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loc</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>LengthNormalization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate autocorrelation for sequence.
signal_letters - Convert these letter(s) to "1" , and rest
of letters in sequence to 0, then calc autocor as in signal analysis.

http://stackoverflow.com/questions/643699/how-can-i-use-numpy-correlate-to-do-autocorrelation
http://stackoverflow.com/questions/13439718/how-to-interpret-numpy-correlate-and-numpy-corrcoef-values?rq=1

#How to Normalize - By Sum ("1's") or seq.length?
lengthNorm = "length" normalization variable.
     By seq.length ("length") or sum of "1"s/signals ("sum").

Loc = Normalization factor,  By Sum ("1's") or length.?
</pre> 
</div>
</div>
<a class="anchor" id="ae15ef6f96924ec48e50aca6ea91dcbea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.calculateProteinCharge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pH</em> = <code>7.2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get Net-Protein charge at given PH. Can alse be Used to predict PI of a protein.
Be careful if used on a "partial" seq - +-N/C termini..
If using only part of a sequence (Just the N-tail etc'), then modify call appropaitely.
http://www.petercollingridge.co.uk/sites/files/peter/predictPI.txt
We could also try using:
http://pythonhosted.org/pyteomics/_modules/pyteomics/electrochem.html#charge
</pre> 
</div>
</div>
<a class="anchor" id="a603ae748d2527d00821a9a1f63f007d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.countToFreq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict_counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets percentage from a provided dict of AA counts.
Could be optimized!.. (Use a list..)
</pre> 
</div>
</div>
<a class="anchor" id="a15b15dca5d5f7374c06f6d27fd11699a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.cysteineMotif </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segDivide</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">CHANGED: Threshhold for counts removed, made into variable feature instead of discrete
Note: We could re-increase the threshhold (min 1 count instead of &gt;1).
And also then divide into more segs..
</pre> 
</div>
</div>
<a class="anchor" id="ae11f6df3b4efbe4e0975089b5a255c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Dict_Keys_prefix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multilevelDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PrefixStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">given a dict, Returns a new dict with prefix_str added before each key.
Also used when using "alternative" alphs (so feature names will be unique,
    i.e "AA_14_KR Freq" vs "KR Freq" (for self.alph==AA_20))
i.e:

&gt;&gt;&gt; aa_dict = {'fruit':'orange','K':0.23}
&gt;&gt;&gt;  print(cds.transform(aa_dict,"entropy"))
</pre> 
</div>
</div>
<a class="anchor" id="ac133108c6d07aa0f3037758307df04a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Entropy_Seq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">DEPRECATE! Use GetEntropy Instead!!

Calculate the (Shannon) information entropy  of a given input string.
Entropy is the expected value of the measure of information content in system.
http://rosettacode.org/wiki/Entropy#Python

Qu - For later comparing to Max Entropy - use possible AA counts?
</pre> 
</div>
</div>
<a class="anchor" id="a9c66b67d86f78d7fd2e9c3f058d07924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.get_netCharge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PH_ranges</em> = <code>[3.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">SLOW!
Return net charge of sequence for range of PH.
Some (Wiki) PH ranges - Lysosomes - 4.5, Granules of chromaffin cells - 5.5,
Cytosol 7.2, Blood 7.34â€“7.45, Mitochondrial matrix - 7.5,
Pancreas secretions 8.1
http://en.wikipedia.org/wiki/PH#Living_systems

PH Of Stress response/oxidization (which can trigger unfolding in some proteins) ?
</pre> 
</div>
</div>
<a class="anchor" id="af7aeb76a124e0b2d6437c62525d76917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Get_ParamScales </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PickScales</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets numerical represention of sequence,
for each amino acid propensity scale (and window size). This is then
used (later) to Get values for sequences using different amino propensities,
via def Get_paramScales.

Default is "built in" scales, but can be expanded easily.

Default window size from literature is !17-19 for detecting TMDs' using hydrophobicity.

Returns a list of (string:list) tuples.
Uses:  Bio.SeqUtils.ProtParam.ProteinAnalysis(protein_scale(self, param_dict, window))
http://biopython.org/DIST/docs/api/Bio.SeqUtils.ProtParamData-module.html - builtin scales

TODO: input "scales to use", "select which".
TODO: Copy AA Scales from Bio.SeqUtils.ProtParamData to AAlphabets.py !
</pre> 
</div>
</div>
<a class="anchor" id="a58835d011020b381bdd83d77220d38e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Get_ParamScales_Features </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PickScales</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract features for given scale/propensity represention of a protein sequence.
Calls on def Get_ParamScales.

Default is to get all "preloaded" scales.
User can choose to use only a limited number of scales, using PickScales

Get 3: max, min, average for each scale.

trim : get average of top/bottom "trim"'%' of values, and av. of in between values.
(i.e. _AverageTrimMAX = average of top 20%,AverageTrimMIN - bottom 20%, and trimAv = Average of remaining 60%)
</pre> 
</div>
</div>
<a class="anchor" id="a48e1171ffa3fa544caf662be9d09b292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Get_PI </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get predicted PI. (Uses BioPython.ProtParam util)
NOTE! For a "parsed"/cleaved subsequence,
This is innaccurate unless fixed! (Doesn't take lack of N/C terminal into account)
</pre> 
</div>
</div>
<a class="anchor" id="ad804cf2dea87e471c03a409a0391b819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Get_SimpleProtParam </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get basic physical properties as in BioPython/ExPasy ProtParam
module.
Returns: PI, MW, GRAVY, aromaticity, Instability index.

Note: These methods all assume a standard AA Alphabet.
Warning! Returned PI is INNACCURATE For a parsed (Tail(s) removed) subseq.
(BioPy-ProtParam.isoelectric_point assumes N,C terminii!)
</pre> 
</div>
</div>
<a class="anchor" id="a41c12ab62255724b9aa96a04700655df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.Get_SubSeqParamScales_Features </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PickScales</em> = <code>MinScales_Dict</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segs</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Similar to "Get_ParamScales_Features", but gets a small(er) set of features (per scale),
for a smaller set (by efault) of AA scales, extracted from multiple segments of the sequence.

Extract features for given scale/propensity represention of a protein sequence.
By default, gets less features (min, max, average), with a minSet of scales. (Includes Atchley).
An alternative, novel implementation is to divide into unequal segments -
first,last 20%, middle 60% (or middle 30% *2). Dan Ofer.
</pre> 
</div>
</div>
<a class="anchor" id="a2ccaa9437f70532d45069e4eb94c3c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetAA_Freq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">amino acid composition (20).
Usage:

result = GetAA_Freq()
</pre> 
</div>
</div>
<a class="anchor" id="a3870adebee4ffffdab545c2f79e09dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetCleavageCounts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>AltLengthNormalize</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get various Potential sites (and/or regions/products),
 associated with cleavage of a precursor sequence/pre-pro-protein into
 products.
 EG: Neuropeptide Precursor processing.
 Many different potential cleavage motifs, dep. on organism, enzymes..!
 Default is Known motif model (Neuropeptides Precursor cleavage via flanking dibasic).:
 Southey et al. (2006b)  Known Motif model comprised of several prevalent motifs
 associated with neuropeptide precursor cleavage:
Xxx-Xxx-Lys-Lys#,
Xxx-Xxx-Lys-Arg#,
Xxx-Xxx-Arg-Arg#,
Arg-Xxx-Xxx-Lys#,
Arg-Xxx-Xxx-Arg#.
  (Xxx = Any AA. # - Cleavage start site. Lys = K. Arg = R)
    Note - In many cases, Proline should NOT be present prior or adjacent to the cl)

 TODO: "Extract" all putative cleaved products/regions, and analyze them
 using AA propensity scales, etc'  (hydrophobicity, flexibility, products...).
 TODO: More sophisticated Furin Cleavage model suggested in:
 "A 20 Residues Motif Delineates the Furin Cleavage Site[...]"
http://www.nuolan.net/motif.html

    TODO: Use external predictor to filter false positives.
Eg: ELM. (Disorder,SS..)
    TODO: Option to input list of RegEx motifs. For other PC (Pre-convertases. not just furin..)

NOTE: Currently, doesn't normalize for length..
</pre> 
</div>
</div>
<a class="anchor" id="a5e9846e49d823597d17b7ce15d959a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetCTD </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctd</em> = <code>'CTD'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get Composition, Transition, Distribution descriptors.
(Currently uses CTD_pro - external module).
ctd = string of letters, according to which C,T,D will be called.

Usage:
result = GetCTD() #Returns all C,T,D
composition = GetCTD('c') #Returns all C.
Comp_And_Distribution =  = GetCTD('CD') #Returns all C and D.
</pre> 
</div>
</div>
<a class="anchor" id="a63273ac1c666696e0c4a3d5abb4480eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.getCysteineMotifs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segDivide</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get Cysteine spacer motif, and counts of frequent CxxC motifs over protein sequence
</pre> 
</div>
</div>
<a class="anchor" id="a24e9a7e4395849f24708b5c29cd61eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetEntropy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalizeTotEntropy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>getLettersEntropy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">http://bugra.github.io/work/notes/2014-05-16/entropy-perplexity-image-text/
VS Entropy_Kap_AA , Entropy_seq..

normalizeTotEntropy : If True, then divide total sequence entropy by log2(length).
                (Check if correct!!)
getLettersEntropy : If True, also return  entropy per letter; If false, then
return only the "total entropy".
</pre> 
</div>
</div>
<a class="anchor" id="ade3d514c79ce995aac26b9744212a9f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.getFIDisorder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Divide protein sequence into segments, and returns for each seg.
predicted disorder (Y/N) according to FoldIndex method (Uversky et al).
Method implemented with help of Tal Arian.
</pre> 
</div>
</div>
<a class="anchor" id="a405aa53e6c8e9b6616739c9e176b8214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetFlex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get parameters for B-values / flexibility. Built for a 9 window window;
alters values from a BioPy ProtParam module.
</pre> 
</div>
</div>
<a class="anchor" id="a0f80df6810f710824dbaab6e30ae3775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetkgramCounts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>UseVariableCombinations</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>IgnoreAlphabetType</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">k-mer peptide composition counts (alphSize^k)

If UseVariableCombinations=False, then calls on a dictionary
of ALL possible k_mer combinations using def NGram_combinations,
(In order to ensure feature count consistency).
This could be skipped, with CARE; (If feature matrix is later kept 'fixed')

Usage:

result = GetkmerFreq()

NOTE: Ideally - n-gram multiLetterComb output dictionary should be saved/pickled,
rather than requiring that it be recalcualted.
By default, length 2 bigram combinations are available for some alphabets.
</pre> 
</div>
</div>
<a class="anchor" id="a8ce3fc3e99eea09835b08d8af39e67c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetkgramFreq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>IgnoreAlphabetType</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get K-mer frequency/composition.

If IgnoreAlphabetType=True, (IS False by default) then don't add
a prefix of the type of reduced aa alph to the feature keys.
(Useful when further manipulating by key/string )
</pre> 
</div>
</div>
<a class="anchor" id="a8b59569502aef30304207fe0303b28c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetKMirrorsFreq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>AddMirrorsPrefix</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>getFreq</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get kmer mirror frequencies: if we assume mirror images of letters to be identical.
Merges "mirror images" and sums their values into the remaining 'key'/image.
(Palindromes are unaffected)
I.E: we treat '01' == '10'. but, "11","00",  not affected. But 'KR' and 'RK' would be.

This gives us a number of combinations acc. to Combination with Replacement, vs "Permutations with Replacement".
https://docs.python.org/3.3/library/itertools.html#itertools.combinations_with_replacement
http://www.calculatorsoup.com/calculators/discretemathematics/combinationsreplacement.php

So: (Pseudocode):   #Function does not currently support passing it kgramFreq directly.
    original_kfreq=self.GetkgramFreq(k=2)
    print(original_kfreq)
    {'01':0.2,'10':0.7,'00':0.0,'11':0.1}
    k_mirrors = GetKgramMirrorFreq(original_kfreq)
    print(k_mirrors)
    {'10':6,'00':0.0,'11':0.1}

For k=4, eg: 0111 would me merged with 1110..

Can be configured to get counts rather than frequencies. (getFreq)</pre> 
</div>
</div>
<a class="anchor" id="ac7bf4d24db5ee443363b023dd9a8f120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetPTMMotifs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Counts occurences of possible PTM motifs.
This is a very weak feature, should be improved using
local sequence properties and external subsequence learning
(average regional flexibility, hydrophobicity, exposure, etc').

We will likely want to replace or augment this with EXTERNAL Predictors.

List of PTM motifs - ELM. (Can also do prediction, accounts for disorder, accessability etc')
http://www.modpred.org/
other predictors..</pre> 
</div>
</div>
<a class="anchor" id="aaffaab7c26455e14f5317d574a428e1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.GetSimpleFeatures </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ParamScaleWindow</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segDivide</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DisorderSegments</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns A large number of "default" features, good for most cases.
This is meant to be called when the sequence is
using the normal 20 letter alphabet. (Otherwise, physical
    parameters returned will be inaccurrate).</pre> 
</div>
</div>
<a class="anchor" id="a76dc57875b17b82b065e4958eb6ec8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.KMirrors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k_dict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a kmer (k_freq?) dict, returns it with mirror images merged and summed.
(Palindromes unaffected).
 = Implementation part of GetKMirrorsFreq
</pre> 
</div>
</div>
<a class="anchor" id="a158fb3fdf8ae66e27116ca58e25752bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.MerCount </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmer_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Counts all occurences of given k-mers (From the
    kmers dictionary's keys)
in the sequence.
Stores counts as values.
</pre> 
</div>
</div>
<a class="anchor" id="a7a9fe63c2f412f7644cc0a814cc5be37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.ordered_seq_pairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns sequence as pairs of bigrams. (Useful for counting).
This function returns (sequentially ordered) letter pairs from seq that
occur at the given distance from each other.

The distance should be an integer larger then 0.

An empty list will be returned if distance is equal to or larger than the
sequence length.

Args:
    seq (str): The sequence of which the pairs are returned
    distance (int): distance between the letter pairs
Returns:
    [(str, str)] List of tuples, each tuple containing two letters of one
         pair. The lengt of the list is max(0, len(seq) - 1).

&gt;&gt;&gt; ordered_seq_pairs('ABCDE', 1)
['AB', 'BC', 'CD', 'DE']
&gt;&gt;&gt; ordered_seq_pairs('ABCDE', 3)
['AD', 'BE']
&gt;&gt;&gt; ordered_seq_pairs('ABCDE', 5)
[]
</pre> 
</div>
</div>
<a class="anchor" id="a06c37ba385c6fa7e877e27a986c273ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def feat_extract.ProtFeat.ProtFeat.tail_properties </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tail_end</em> = <code>'N'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>GetFullAAFreq</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reduced_alph</em> = <code>'Ofer_N_Tail'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Method that gets a number of N or C end terminii tail/subsequence's
properties.
IMPORTANT! This method assumed that the self object/protein constructed
 is JUST the tail!
 (I.E - it is NOT meant to be used on part of an instance's own sequence,
    but to be called in the subsequence as its own, constructd object/).

Note: Differences in calling netCharge, paramscale...
PH is currently innacurate in assuming a terminii end.
Assume N-length as being fixed (~25). Likely reduced in its AA alphabet.
Consider whether to use AA frequency or counts.

Signal Peptides in Euk are usually ~15-25 AA long,
often composed of 3 subsections: "charged+"-"Hydrophobic"-"Polar(uncharged)".
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ProtFeat.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 1 2015 14:56:19 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
